<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2048: Cosmic Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #05050a;
            --cyan: #00f2ea;
            --purple: #bf00ff;
            --gold: #FFD700;
            --font-head: 'Orbitron', sans-serif;
            --font-body: 'Poppins', sans-serif;
            --tile-empty: rgba(255, 255, 255, 0.05);
        }

        body {
            margin: 0; background-color: var(--bg-dark); color: #fff;
            font-family: var(--font-head); overflow: hidden; height: 100vh;
            display: flex; flex-direction: column; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- BACKGROUND FX --- */
        .nebula-bg { position: fixed; top: 0; left: 0; width: 100vw; height: 100%; z-index: -2; background: radial-gradient(circle at 50% 50%, #1a0b2e, #05050a 80%); }
        .star-field { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.6; background-image: radial-gradient(2px 2px at 40% 40%, rgba(255,255,255,0.8), transparent); background-size: 300px 300px; animation: drift 60s linear infinite; }
        @keyframes drift { from { background-position: 0 0; } to { background-position: 0 300px; } }

        /* --- UI BAR --- */
        .ui-bar {
            height: 60px; display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; z-index: 10; background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px); border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .home-btn {
            background: rgba(255,255,255,0.1); border: 1px solid var(--cyan); 
            color: var(--cyan); padding: 5px 12px; border-radius: 20px; 
            font-size: 0.8rem; cursor: pointer; text-decoration: none; 
            transition: 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .home-btn:active { transform: scale(0.95); background: var(--cyan); color: #000; }
        
        .stats-group { display: flex; gap: 20px; }
        .stat-box { text-align: center; }
        .stat-label { font-size: 0.6rem; color: #aaa; letter-spacing: 1px; }
        .stat-val { font-size: 1.2rem; color: var(--gold); text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }

        /* --- GAME CONTAINER --- */
        #game-wrapper {
            flex: 1; display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            width: 100%; max-width: 500px; margin: 0 auto;
        }

        #grid-container {
            position: relative;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--purple);
            box-shadow: 0 0 30px rgba(191, 0, 255, 0.2);
            padding: 10px;
            border-radius: 10px;
            width: 300px; height: 300px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            touch-action: none;
        }

        .tile {
            background-color: var(--tile-empty);
            border-radius: 6px;
            display: flex; justify-content: center; align-items: center;
            font-size: 30px; font-weight: bold; color: #fff;
            transition: transform 0.1s, box-shadow 0.2s;
            position: relative;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.05);
        }

        /* --- NEON TILE STYLES --- */
        .tile[data-val="2"] { border-color: #fff; color: #fff; box-shadow: 0 0 5px rgba(255,255,255,0.2); }
        .tile[data-val="4"] { border-color: #ede0c8; color: #ede0c8; }
        .tile[data-val="8"] { border-color: #f2b179; color: #f2b179; box-shadow: 0 0 10px rgba(242, 177, 121, 0.3); }
        .tile[data-val="16"] { border-color: #f59563; background: rgba(245, 149, 99, 0.2); box-shadow: 0 0 10px rgba(245, 149, 99, 0.4); }
        .tile[data-val="32"] { border-color: #f67c5f; background: rgba(246, 124, 95, 0.2); box-shadow: 0 0 15px rgba(246, 124, 95, 0.5); }
        .tile[data-val="64"] { border-color: #f65e3b; background: rgba(246, 94, 59, 0.2); box-shadow: 0 0 20px rgba(246, 94, 59, 0.6); }
        .tile[data-val="128"] { border-color: var(--cyan); background: rgba(0, 242, 234, 0.15); box-shadow: 0 0 20px var(--cyan); font-size: 24px; text-shadow: 0 0 10px var(--cyan); }
        .tile[data-val="256"] { border-color: var(--cyan); background: rgba(0, 242, 234, 0.25); box-shadow: 0 0 30px var(--cyan); font-size: 24px; }
        .tile[data-val="512"] { border-color: var(--purple); background: rgba(191, 0, 255, 0.2); box-shadow: 0 0 20px var(--purple); font-size: 24px; text-shadow: 0 0 10px var(--purple); }
        .tile[data-val="1024"] { border-color: var(--purple); background: rgba(191, 0, 255, 0.3); box-shadow: 0 0 35px var(--purple); font-size: 20px; }
        .tile[data-val="2048"] { border-color: var(--gold); background: rgba(255, 215, 0, 0.3); box-shadow: 0 0 40px var(--gold); font-size: 20px; animation: pulse 1.5s infinite; text-shadow: 0 0 10px var(--gold); }
        
        @keyframes pulse { 0% { transform: scale(1); box-shadow: 0 0 20px var(--gold); } 50% { transform: scale(1.05); box-shadow: 0 0 50px var(--gold); } 100% { transform: scale(1); box-shadow: 0 0 20px var(--gold); } }
        
        /* Spawn/Merge Animation */
        .pop { animation: pop 0.2s ease-out; }
        @keyframes pop { 0% { transform: scale(0.5); opacity:0; } 80% { transform: scale(1.1); opacity:1; } 100% { transform: scale(1); } }

        .hint-text {
            margin-top: 20px; color: #666; font-size: 0.8rem; letter-spacing: 1px;
            font-family: var(--font-body);
        }

        /* --- MODAL --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.9); backdrop-filter: blur(5px);
            z-index: 20; display: none; flex-direction: column; 
            justify-content: center; align-items: center; border-radius: 10px;
        }
        h2 { margin: 0 0 10px 0; font-size: 2rem; color: var(--gold); text-shadow: 0 0 15px var(--gold); }
        
        .btn-action {
            background: linear-gradient(45deg, var(--cyan), var(--purple));
            border: none; padding: 10px 25px; font-family: var(--font-head); 
            font-size: 1rem; font-weight: bold; color: #fff; border-radius: 20px; 
            cursor: pointer; box-shadow: 0 0 15px rgba(0, 242, 234, 0.3);
            transition: 0.2s;
        }
        .btn-action:active { transform: scale(0.95); }

    </style>
</head>
<body>

    <div class="nebula-bg"></div>
    <div class="star-field"></div>

    <div class="ui-bar">
        <a href="#" class="home-btn" onclick="exitGame()">âœ• EXIT</a>
        <div class="stats-group">
            <div class="stat-box">
                <div class="stat-label">SCORE</div>
                <div class="stat-val" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">BEST</div>
                <div class="stat-val" id="best-score">0</div>
            </div>
        </div>
    </div>

    <div id="game-wrapper">
        <div id="grid-container">
            <div id="overlay">
                <h2 id="msg-text">GAME OVER</h2>
                <button class="btn-action" onclick="initGame()">RESTART SYSTEM</button>
            </div>
        </div>
        <div class="hint-text">SWIPE OR ARROW KEYS</div>
    </div>

<script>
    const gridContainer = document.getElementById('grid-container');
    const scoreDisplay = document.getElementById('score');
    const bestDisplay = document.getElementById('best-score');
    const overlay = document.getElementById('overlay');
    const msgText = document.getElementById('msg-text');
    
    let grid = [];
    let score = 0;
    let highScore = localStorage.getItem('2048_best') || 0;
    const size = 4;

    bestDisplay.innerText = highScore;

    // --- Core Game Logic ---

    function initGame() {
        grid = Array(size).fill().map(() => Array(size).fill(0));
        score = 0;
        updateScore(0);
        overlay.style.display = 'none';
        
        // Remove old tiles (except overlay)
        const oldTiles = gridContainer.querySelectorAll('.tile');
        oldTiles.forEach(t => t.remove());

        addNewTile();
        addNewTile();
        renderGrid();
    }

    function addNewTile() {
        const emptyTiles = [];
        for(let r=0; r<size; r++) {
            for(let c=0; c<size; c++) {
                if(grid[r][c] === 0) emptyTiles.push({r, c});
            }
        }
        
        if(emptyTiles.length > 0) {
            const {r, c} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            grid[r][c] = Math.random() < 0.9 ? 2 : 4;
            return {r, c, val: grid[r][c]}; // Return info for animation
        }
        return null;
    }

    function renderGrid() {
        // Clear visually
        const tiles = gridContainer.querySelectorAll('.tile');
        tiles.forEach(t => t.remove());

        // Rebuild
        for(let r=0; r<size; r++) {
            for(let c=0; c<size; c++) {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                const value = grid[r][c];
                
                if(value > 0) {
                    tile.textContent = value;
                    tile.setAttribute('data-val', value);
                }
                
                // Keep grid layout order
                gridContainer.appendChild(tile);
            }
        }
        // Ensure overlay is on top
        gridContainer.appendChild(overlay);
    }

    function updateScore(add) {
        if(add !== undefined) score = add;
        scoreDisplay.textContent = score;
        if(score > highScore) {
            highScore = score;
            bestDisplay.textContent = highScore;
            localStorage.setItem('2048_best', highScore);
        }
    }

    // --- Movement Logic ---

    function slide(row) {
        // 1. Filter zeros
        let arr = row.filter(val => val);
        // 2. Merge
        for(let i=0; i < arr.length - 1; i++) {
            if(arr[i] === arr[i+1]) {
                arr[i] *= 2;
                score += arr[i];
                arr[i+1] = 0;
            }
        }
        // 3. Filter zeros again
        arr = arr.filter(val => val);
        // 4. Pad
        while(arr.length < size) arr.push(0);
        return arr;
    }

    function move(direction) {
        let hasMoved = false;
        let originalGrid = JSON.stringify(grid);
        let oldScore = score;

        if (direction === 'ArrowLeft') {
            for(let r=0; r<size; r++) grid[r] = slide(grid[r]);
        } else if (direction === 'ArrowRight') {
            for(let r=0; r<size; r++) {
                let reversed = grid[r].reverse();
                let newRow = slide(reversed);
                grid[r] = newRow.reverse();
            }
        } else if (direction === 'ArrowUp') {
            for(let c=0; c<size; c++) {
                let col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]];
                let newCol = slide(col);
                for(let r=0; r<size; r++) grid[r][c] = newCol[r];
            }
        } else if (direction === 'ArrowDown') {
            for(let c=0; c<size; c++) {
                let col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]];
                let reversed = col.reverse();
                let newCol = slide(reversed);
                newCol = newCol.reverse();
                for(let r=0; r<size; r++) grid[r][c] = newCol[r];
            }
        }

        if(JSON.stringify(grid) !== originalGrid) {
            updateScore(score); // Update UI
            addNewTile();
            renderGrid();
            checkGameState();
        }
    }

    function checkGameState() {
        // Check 2048 (Win Condition - Optional, usually endless)
        // Check Game Over
        let movesAvailable = false;
        
        // Empty spots?
        for(let r=0; r<size; r++) {
            for(let c=0; c<size; c++) if(grid[r][c] === 0) movesAvailable = true;
        }

        // Horizontal merges?
        if(!movesAvailable) {
            for(let r=0; r<size; r++) {
                for(let c=0; c<size-1; c++) if(grid[r][c] === grid[r][c+1]) movesAvailable = true;
            }
        }

        // Vertical merges?
        if(!movesAvailable) {
            for(let c=0; c<size; c++) {
                for(let r=0; r<size-1; r++) if(grid[r][c] === grid[r+1][c]) movesAvailable = true;
            }
        }

        if(!movesAvailable) {
            gameOver();
        }
    }

    function gameOver() {
        msgText.textContent = "GRID LOCKED";
        overlay.style.display = 'flex';
        
        // Send score to Parent
        if(window.parent) {
            window.parent.postMessage({
                type: 'game_over',
                game: '2048',
                score: score
            }, '*');
        }
    }

    function exitGame() {
        if(window.parent) window.parent.postMessage('close_game', '*');
    }

    // --- Input Handling ---

    document.addEventListener('keydown', (e) => {
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
            move(e.key);
        }
    });

    // Touch
    let touchStartX = 0, touchStartY = 0;

    gridContainer.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, {passive: false});

    gridContainer.addEventListener('touchend', (e) => {
        let touchEndX = e.changedTouches[0].screenX;
        let touchEndY = e.changedTouches[0].screenY;
        handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
    }, {passive: false});

    function handleSwipe(x1, y1, x2, y2) {
        let dx = x2 - x1;
        let dy = y2 - y1;
        
        if(Math.abs(dx) > Math.abs(dy)) {
            if(Math.abs(dx) > 30) move(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
        } else {
            if(Math.abs(dy) > 30) move(dy > 0 ? 'ArrowDown' : 'ArrowUp');
        }
    }

    initGame();

</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #05050a; color: #fff; font-family: 'Orbitron', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; touch-action: none; }
        
        #grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; background: #222; padding: 5px; border-radius: 5px; width: 90vw; max-width: 350px; aspect-ratio: 1; }
        .cell { background: #333; border-radius: 2px; }
        .block-filled { background: #00e676; box-shadow: 0 0 5px #00e676; }
        
        #score-display { font-size: 2rem; margin-bottom: 20px; color: #00e676; }
        .back-btn { position: absolute; top: 20px; left: 20px; font-size: 2rem; cursor: pointer; }

        /* Draggable shapes container */
        #shapes-container { display: flex; gap: 10px; margin-top: 20px; height: 100px; width: 100%; justify-content: center; }
        .shape-preview { width: 60px; height: 60px; display: grid; gap: 2px; cursor: grab; touch-action: none; }
        .p-cell { background: #00e676; width: 100%; height: 100%; }

        #game-over { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center; z-index: 20; }
        button { background: #00e676; border: none; padding: 15px 30px; font-weight: bold; font-family: 'Orbitron'; font-size: 1.2rem; cursor: pointer; border-radius: 30px; }
    </style>
</head>
<body>
    <div class="back-btn" onclick="window.parent.postMessage('close_game', '*')">âœ•</div>
    <div id="score-display">0</div>
    <div id="grid"></div>
    <div id="shapes-container"></div>

    <div id="game-over">
        <h1>NO MOVES</h1>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <script>
        // SIMPLIFIED BLOCK BLAST (Tap to place for web compatibility)
        // In a full version, Drag & Drop is complex. Here we use "Select & Tap Grid" logic.
        
        const GRID_SIZE = 8;
        let grid = Array(GRID_SIZE * GRID_SIZE).fill(0);
        let score = 0;
        let currentShapes = [];
        let selectedShapeIdx = -1;

        const SHAPES = [
            [[1,1],[1,1]], // Square
            [[1,1,1]], // Line 3
            [[1],[1],[1]], // V-Line 3
            [[1,0],[1,1],[1,0]], // T
            [[1,1,0],[0,1,1]] // Z
        ];

        function init() {
            renderGrid();
            spawnShapes();
        }

        function renderGrid() {
            const el = document.getElementById('grid');
            el.innerHTML = '';
            grid.forEach((val, i) => {
                const cell = document.createElement('div');
                cell.className = 'cell ' + (val ? 'block-filled' : '');
                cell.onclick = () => placeShape(i);
                el.appendChild(cell);
            });
        }

        function spawnShapes() {
            const container = document.getElementById('shapes-container');
            container.innerHTML = '';
            currentShapes = [];
            
            for(let i=0; i<3; i++) {
                const template = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                currentShapes.push({ data: template, used: false });
                
                // Draw Preview
                const sDiv = document.createElement('div');
                sDiv.className = 'shape-preview';
                sDiv.style.gridTemplateColumns = `repeat(${template[0].length}, 1fr)`;
                sDiv.onclick = () => selectShape(i, sDiv);
                
                template.flat().forEach(bit => {
                    const p = document.createElement('div');
                    if(bit) p.className = 'p-cell';
                    sDiv.appendChild(p);
                });
                container.appendChild(sDiv);
            }
            selectedShapeIdx = -1;
        }

        function selectShape(idx, el) {
            if(currentShapes[idx].used) return;
            document.querySelectorAll('.shape-preview').forEach(e => e.style.border = 'none');
            selectedShapeIdx = idx;
            el.style.border = '2px solid #fff';
        }

        function placeShape(gridIdx) {
            if(selectedShapeIdx === -1) return;
            const shape = currentShapes[selectedShapeIdx].data;
            const r = Math.floor(gridIdx / GRID_SIZE);
            const c = gridIdx % GRID_SIZE;

            // Check if fits
            let canFit = true;
            let cellsToFill = [];

            for(let i=0; i<shape.length; i++) {
                for(let j=0; j<shape[0].length; j++) {
                    if(shape[i][j] === 1) {
                        let targetR = r + i;
                        let targetC = c + j;
                        let idx = targetR * GRID_SIZE + targetC;
                        
                        if(targetR >= GRID_SIZE || targetC >= GRID_SIZE || grid[idx] === 1) {
                            canFit = false;
                        } else {
                            cellsToFill.push(idx);
                        }
                    }
                }
            }

            if(canFit) {
                // Place
                cellsToFill.forEach(idx => grid[idx] = 1);
                score += cellsToFill.length;
                document.getElementById('score-display').innerText = score;
                
                // Mark used
                currentShapes[selectedShapeIdx].used = true;
                document.querySelectorAll('.shape-preview')[selectedShapeIdx].style.visibility = 'hidden';
                selectedShapeIdx = -1;

                // Check Lines
                checkLines();
                renderGrid();

                // Check Refill
                if(currentShapes.every(s => s.used)) spawnShapes();

                // Send Score Live
                window.parent.postMessage({ type: 'game_over', game: 'blast', score: score }, '*');
            }
        }

        function checkLines() {
            // Rows
            for(let r=0; r<GRID_SIZE; r++) {
                let row = [];
                for(let c=0; c<GRID_SIZE; c++) row.push(r*GRID_SIZE + c);
                if(row.every(idx => grid[idx] === 1)) {
                    row.forEach(idx => grid[idx] = 0);
                    score += 10;
                    window.parent.postMessage({ type: 'stardust_collected' }, '*');
                }
            }
            // Columns (Simplified for this snippet - typically you check both then clear)
        }

        init();
    </script>
</body>
</html>
